<?xml version="1.0" encoding="utf-8" ?> 
<GameLib>
 <IO>
  <IOH>
   <BinaryFormat>
    <remarks>
     <para>The binary formatters allow you to format binary data in a way analogous to using
      <see cref="Console.Write"/> or <see cref="String.Format"/> to format text. The following format codes are
      recognized, and examples are given below. 
     </para>
<code>
Code  Writes/Effect           Parameter
----------------------------------------
x     Zero bytes              NONE
b     Signed bytes            Array/Val.
B     Unsigned bytes          Array/Val.
w     Signed words            Array/Val.
W     Unsigned words          Array/Val.
d     Signed doublewords      Array/Val.
D     Unsigned doublewords    Array/Val.
q     Signed quadwords        Array/Val.
Q     Unsigned quadwords      Array/Val.
f     Floats                  Array/Val.
F     Doubles                 Array/Val.
c     Characters              Array/Val.
s     A string                String
p     A pascal string         String
A     Sets ASCII mode         NONE
U     Sets Unicode mode       NONE
&lt;     Sets little-endian mode NONE
&gt;     Sets big-endian mode    NONE
=     Sets default endianness NONE
</code>
     <para>Whitespace between tokens in the format string is ignored, so you can use whitespace to make the format
      string more readable. Whitespace between a prefix and the associated format code is not allowed, however
      (this restriction may be relaxed in the future).
     </para>
     <para>The <c>x</c> code and all codes that take parameters also take a prefix. A prefix is a positive integer
      or a question mark added before the code to specify a count of items. If not specified, the prefix defaults to
      1 (except for string codes <c>s</c> and <c>p</c>, where it defaults to the length of the string). If the prefix
      is a question mark, an array parameter or string is expected (depending on the code chosen), and the prefix is
      set to the length of the array or string.
     </para>
     <para>The <c>p</c> code specifies a pascal string, which has the length of the string stored in the byte before
      the string itself. Because only one byte is allocated for the length, pascal strings are limited to 255
      characters in length. Without a prefix, if a string is passed that is longer than that, it will be silently
      truncated to 255 characters. If a prefix greater than 255 is specified for a pascal string, an error will occur.
     </para>
     <para>If a prefix is passed for a string code (<c>s</c> or <c>p</c>) and the prefix is longer than the string
      given as an argument, the remaining characters will be written as zeros to reach the length given in the prefix.
     </para>
     <para>Codes that take Array/Val. as a parameter either take an array of the specified type or a list of
      values convertible to that type (using the System.Convert class). For instance, the 'w' code takes either an
      array of signed words or a literal list of values convertible to signed words, with a number of values equal
      to the prefix.
     </para>
     <para>The codes that write words, doublewords, and quadwords are affected by the endianness mode. The default
      endianness is set to the default for the system the code is running on. It can be changed with the <c>&lt;</c>,
      <c>&gt;</c>, and <c>=</c> codes.
     </para>
     <para>The <c>s</c>, <c>p</c>, and <c>c</c> codes are affected by the character mode. By default, the character
      mode is ASCII, but it can be changed with <c>A</c> and <c>U</c>. If the character mode is ASCII, characters will
      be written out as single bytes and strings will be converted to ASCII before being written. Otherwise,
      characters are written using two bytes each and strings will not be encoded before being written. If the
      character mode is set to Unicode, then the endianness mode determines the endianness of the words written for
      each character.
     </para>
     <para>See the following examples:</para>
<code>
// A simple example that first writes an array's length, and then writes the
// contents of the array (of integers), using default endianness.
IOH.Write(stream, "d?d", Array.Length, Array);

// An example taken from some .PSD writing code to begin the header. It
// writes the signature (8BPS) as ASCII, the version byte (1), six padding
// bytes, the number of channels (a word), the dimensions of the image (two
// integers), and two words specifying the bit depth per channel (8) and
// color mode (3 = RGB), using big-endian output.
// It uses whitespace to make the string a bit more readable.
IOH.Write(stream, "&gt;s B 6x w 2d 2w", "8BPS", 1, image.Channels,
          image.Height, image.Width, 8, 3);

// This is illegal because whitespace between a prefix and its associated
// format code is currently not allowed.
IOH.Write(stream, "6 x"); // write 6 zeros?

// This example uses IOH.CalculateSize() and IOH.Write() in part of a
// network serialization implementation. It writes the player's name as
// a pascal string, the player's position, the length of a byte array,
// and the byte array itself, using big-endian output.
public int SizeOf()
{ return IOH.CalculateSize("&gt;p3d?B", player.Name, byteArray);
}
public void SerializeTo(byte[] buf, int index)
{ IOH.Write(buf, index, "&gt;p3d?B", player.Name, player.X, player.Y,
            byteArray.Length, byteArray);
}
</code>
    </remarks>
   </BinaryFormat>
  </IOH>
 </IO>
</GameLib>