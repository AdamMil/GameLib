<?xml version="1.0" encoding="utf-8" ?> 
<GameLib>
  <IComparable>
    <CompareTo>
      <summary>Compares the current instance with another object of the same type.</summary>
      <param name="obj">An object to compare with this instance.</param>
      <returns>An integer that indicates the relative order of the comparands. The return value has these meanings:
      <list type="table">
      <listheader><term>Value</term><description>Meaning</description></listheader>
      <item><term>Less than zero</term><description>This instance is less than <paramref name="obj"/>.</description></item>
      <item><term>Zero</term><description>This instance is equal to <paramref name="obj"/>.</description></item>
      <item><term>Greater than zero</term><description>This instance is greater than <paramref name="obj"/>.</description></item>
      </list>
      </returns>
    </CompareTo>
  </IComparable>

  <IConvertible>
    <ToUInt64>
      <summary>Converts this value to a <see cref="UInt64"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>A <see cref="UInt64"/> representing this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToUInt64>
    <ToSByte>
      <summary>Converts this value to an <see cref="SByte"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>An <see cref="SByte"/> representing this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToSByte>
    <ToDouble>
      <summary>Converts this value to a <see cref="Double"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>The <see cref="Double"/> closest to this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToDouble>
    <ToSingle>
      <summary>Converts this value to a <see cref="Single"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>The <see cref="Single"/> closest to this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToSingle>
    <ToInt32>
      <summary>Converts this value to an <see cref="Int32"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>An <see cref="Int32"/> representing this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToInt32>
    <ToUInt16>
      <summary>Converts this value to a <see cref="UInt16"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>A <see cref="UInt16"/> representing this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToUInt16>
    <ToInt16>
      <summary>Converts this value to an <see cref="Int16"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>An <see cref="Int16"/> representing this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToInt16>
    <ToString>
      <summary>Converts this value to a string.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>An string representing this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToString>
    <ToByte>
      <summary>Converts this value to a <see cref="Byte"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>An <see cref="Byte"/> representing this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToByte>
    <ToChar>
      <summary>Converts this value to a <see cref="Char"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>An <see cref="Char"/> representing this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToChar>
    <ToInt64>
      <summary>Converts this value to an <see cref="Int64"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>An <see cref="Int64"/> representing this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToInt64>
    <ToDecimal>
      <summary>Converts this value to a <see cref="Decimal"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>A <see cref="Decimal"/> representing this value.</returns>
    </ToDecimal>
    <ToType>
      <summary>Converts the value to the given type.</summary>
      <param name="conversionType">The type to which this value should be converted.</param>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>An object containing this value converted to the given type.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
      <exception cref="InvalidCastException">Thrown if no conversion to the destination type exists.</exception>
    </ToType>
    <ToUInt32>
      <summary>Converts this value to a <see cref="UInt32"/>.</summary>
      <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
      <returns>A <see cref="UInt32"/> representing this value.</returns>
      <exception cref="OverflowException">Thrown if the value cannot be represented by the return type.</exception>
    </ToUInt32>
  </IConvertible>

  <Fonts>
    <LineSkip>
      <summary>Gets the vertical offset that should be added to move the draw position to the next line. This is
        equivalent to the height of the font plus spacing between lines.
      </summary>
    </LineSkip>

    <CalculateSize>
      <summary>Calculates the size of a string of text.</summary>
      <param name="text">The text to use for the calculation.</param>
      <returns>A <see cref="Size"/> that contains the amount of space required to render the given text with this
        font.
      </returns>
      <remarks>This method does not perform word-wrapping on the text, and returns a calculation assuming the text
        is rendered as a single line.
      </remarks>
    </CalculateSize>

    <HowManyFit>
      <summary>Calculates how many characters of the given string would fit into the given width.</summary>
      <param name="text">The string to test.</param>
      <param name="width">The available width, in pixels.</param>
      <returns>The number of characters that would fully fit within the given width.</returns>
    </HowManyFit>
    
    <Render>
      <Point>
        <Common>
          <summary>Renders text at a given point.</summary>
          <param name="dest">The surface to render into.</param>
          <param name="text">The text to render.</param>
          <returns>Returns the width of the text rendered plus spacing so that you can use the value to calculate where
          more text can be rendered (by adding the returned width to the starting position).
          </returns>
        </Common>
        <Pt>
          <include file="documentation.xml" path="//Fonts/Render/Point/Common/*"/>
          <param name="pt">The point where the top-left corner of the rendered text should appear.</param>
        </Pt>
        <XY>
          <include file="documentation.xml" path="//Fonts/Render/Point/Common/*"/>
          <param name="x">The X coordinate where the left side of the rendered text should appear.</param>
          <param name="y">The Y coordinate where the top edge of the rendered text should appear.</param>
        </XY>
      </Point>
      
      <Rect>
        <Common>
          <summary>Word-wraps and renders text into a given rectangle.</summary>
          <param name="dest">The surface to render into.</param>
          <param name="text">The text to render.</param>
          <param name="rect">The area into which text will be rendered.</param>
        </Common>
        <Align>
          <include file="documentation.xml" path="//Fonts/Render/Rect/Common/*"/>
          <param name="align">The <see cref="ContentAlignment"/> to use inside the rectangle.</param>
          <returns>Returns the end point of the rendering, where rendering can be continue with more text.
          This only works with top-left alignment, since the endpoints for other types of alignment require before-hand
          knowledge of the amount of text. For other alignment types, the value of the returned point is undefined.
          </returns>
        </Align>
        <NoAlign>
          <include file="documentation.xml" path="//Fonts/Render/Rect/Common/*"/>
          <returns>Returns the end point of the rendering, where rendering can be continue with more text.</returns>
        </NoAlign>
        <Offset>
          <param name="startx">The X offset into the rectangle at which rendering will begin.</param>
          <param name="starty">The Y offset into the rectangle at which rendering will begin.</param>
        </Offset>
      </Rect>
    </Render>
    
    <WordWrap>
      <Common>
        <summary>Word-wraps text into a specified area.</summary>
        <param name="text">The text to word-wrap.</param>
        <returns>An array of integers specifying indices into the string. There is one element for each line of text.
          The value of the element is how many characters should be rendered on that line.
        </returns>
        <remarks>Currently, a newline character will not force a line break. This behavior will be changed in the
          future.
        </remarks>
      </Common>
      <Size>
        <include file="documentation.xml" path="//Fonts/WordWrap/Common/*"/>
        <param name="size">The size of the area bounding the text.</param>
      </Size>
      <Rect>
        <include file="documentation.xml" path="//Fonts/WordWrap/Common/*"/>
        <param name="rect">The area bounding the text.</param>
      </Rect>
      <Dims>
        <include file="documentation.xml" path="//Fonts/WordWrap/Common/*"/>
        <param name="width">The width of the area bounding the text.</param>
        <param name="height">The height of the area bounding the text.</param>
      </Dims>
      <Offset>
        <param name="startx">The X offset into the rectangle at which the text should start.</param>
        <param name="starty">The Y offset into the rectangle at which the text should start.</param>
      </Offset>
      <Breakers>
        <param name="breakers">An array of characters that will be used to break the text. Those characters will
          mark preferred places within the string to break to a new line.
        </param>
      </Breakers>
    </WordWrap>

    <BitmapFont>
      <Common>
        <param name="font">A surface containing the font data.</param>
        <param name="charset">A list of characters in the font, in the order in which they appear in the image.
        The font class can operate much more efficiently if the characters in the character set are contiguous.
        That is, for each each character, its value is one greater than value of the previous character.
        </param>
      </Common>
      <BitmapFont1>
        <include file="documentation.xml" path="//Fonts/BitmapFont/Common/*"/>
        <param name="charWidth">The width of the characters in the font.</param>
        <remarks>The surface should contain all the characters, in the order specified by <paramref name="charset"/>,
        all in a single row. Each character should be <paramref name="charWidth"/> pixels wide, and there should be no
        unused space anywhere. If the surface has a color key or alpha channel, it will be used.
        </remarks>
      </BitmapFont1>
      <BitmapFont2>
        <include file="documentation.xml" path="//Fonts/BitmapFont/Common/*"/>
        <param name="charWidths">An array the same length as <paramref name="charset"/>, containing the width of each
        character.
        </param>
        <remarks>The surface should contain all the characters, in the order specified by <paramref name="charset"/>,
        all in a single row. Each character should the number of pixels specified in <paramref name="charWidths"/>
        pixels wide, and there should be no unused space anywhere. If the surface has a color key or alpha channel,
        it will be used.
        </remarks>
      </BitmapFont2>
    </BitmapFont>
    
    <TrueTypeFont>
      <Cons>
        <Stream>
          <summary>Initializes this font from a stream containing TrueType font data.</summary>
          <param name="stream">The stream to read the font from. The stream must be seekable, with its entire set of
          data devoted to the font.
          </param>
          <param name="pointSize">The size of the font, in points (based on 72dpi).</param>
        </Stream>
        <File>
          <summary>Initializes this font from a file on disk.</summary>
          <param name="filename">The path to the TrueType font file.</param>
          <param name="pointSize">The size of the font, in points (based on 72dpi).</param>
        </File>
        <Index>
          <param name="fontIndex">Some fonts contain multiple faces. This parameter selects which face to use
            (zero-based).
          </param>
        </Index>
        <AutoClose>
          <param name="autoClose">If true, the stream will be closed after the font is loaded.</param>
        </AutoClose>
        <WillClose>
          <remarks>The stream will be closed after the font is loaded.</remarks>
        </WillClose>
      </Cons>
    </TrueTypeFont>
 </Fonts>

 <IO>
  <StreamStream> <!-- StreamStream class -->
   <StreamStream>
    <summary>Initializes this stream.</summary>
    <param name="start">The starting offset into <paramref name="stream"/> where this stream will begin.</param>
    <param name="length">The length of this stream.</param>
    <remarks>When using seekable streams, the StreamStream's <see cref="Position"/> property will always begin
    at the beginning of the range given to the constructor. With unseekable streams, however, this may not be
    possible. If the underlying stream's <see cref="Stream.Position"/> is before <paramref name="start"/>, it will
    be advanced forward to <paramref name="start"/>. If it's after <paramref name="start"/> but still within the
    range, then the StreamStream's <see cref="Position"/> property will set to the offset from
    <paramref name="start"/>. If the underlying stream's <see cref="Stream.Position"/> is past the end of the range
    (greater than <see cref="start"/> plus <see cref="length"/>) then an exception will be thrown because the
    StreamStream cannot possibly be in a valid state. Similarly, since shared streams are seeked to the expected
    position before each operation, unseekable streams cannot be shared.
    </remarks>
   </StreamStream>
  </StreamStream>

  <IOH>
   <BinaryFormat> <!-- BinaryFormat codes -->
    <remarks>
     <para>The binary formatters allow you to format binary data in a way analogous to using
      <see cref="Console.Write"/> or <see cref="String.Format"/> to format text. The following format codes are
      recognized, and examples are given below. 
     </para>
<code>
Code  Writes/Effect           Parameter
----------------------------------------
x     Zero bytes              NONE
b     Signed bytes            Array/Vals
B     Unsigned bytes          Array/Vals
w     Signed words            Array/Vals
W     Unsigned words          Array/Vals
d     Signed doublewords      Array/Vals
D     Unsigned doublewords    Array/Vals
q     Signed quadwords        Array/Vals
Q     Unsigned quadwords      Array/Vals
f     Floats                  Array/Vals
F     Doubles                 Array/Vals
c     Characters              Array/Vals
s     A string                String
p     A pascal string         String
A     Sets ASCII mode         NONE
U     Sets Unicode mode       NONE
&lt;     Sets little-endian mode NONE
&gt;     Sets big-endian mode    NONE
=     Sets default endianness NONE
</code>
     <para>Whitespace between tokens in the format string is ignored, so you can use whitespace to make the format
      string more readable. However, whitespace between a prefix and its associated format code is not allowed
      (this restriction may be relaxed in the future).
     </para>
     <para>The <c>x</c> code and all codes that take parameters also take an optional prefix. A prefix is a positive
      integer or a question mark added before the code to specify a count of items. If not specified, the prefix
      defaults to 1 (except for string codes <c>s</c> and <c>p</c>, where it defaults to the length of the string).
      If the prefix is a question mark, an array or string is expected (depending on the code chosen), and the prefix
      is set to the length of the array or string.
     </para>
     <para>The <c>p</c> code specifies a pascal string, which has the length of the string stored in the byte before
      the string itself. Because only one byte is allocated for the length, pascal strings are limited to 255
      characters in length. Without a prefix (or a prefix of '?'), if a string is passed that is longer than that, it
      will be silently truncated to 255 characters. If a prefix greater than 255 is specified for a pascal string, an
      error will occur.
     </para>
     <para>If a prefix is passed for a string code (<c>s</c> or <c>p</c>) and the prefix is longer than the string
      parameter, the remaining characters will be written as NILs (value of zero) to reach the length given in the
      prefix.
     </para>
     <para>Codes that take Array/Vals as a parameter either take an array of the specified type or a list of
      values convertible to that type (using the <see cref="System.Convert"/> class). For instance, the 'w' code
      takes either an array of signed words or a literal list of values convertible to signed words, with a number
      of values equal to the prefix. You may be surprised by the semantics of the <see cref="System.Convert"/> class,
      however, so see its documentation to see how it converts values.
     </para>
     <para>The codes that write words, doublewords, and quadwords are affected by the endianness mode. Unicode
      characters and strings are also affected. The default endianness is set to the default for the system the code
      is running on. It can be changed with the <c>&lt;</c>, <c>&gt;</c>, and <c>=</c> codes. The endianness mode
      can be changed in the middle of the format string if you want to write some data using one endianness
      mode and some other data with another mode.
     </para>
     <para>The <c>s</c>, <c>p</c>, and <c>c</c> codes are affected by the character mode. By default, the character
      mode is ASCII, but it can be changed with the <c>A</c> and <c>U</c> codes. If the character mode is ASCII,
      characters will be written out as single bytes and strings will be converted to ASCII before being written.
      Otherwise, if the character mode is set to Unicode, strings will not be encoded before being written and
      characters will be written using two bytes each with the order determined by the current endianness mode.
      The character mode can be changed in the middle of the format string if you want to write some data using
      one character mode and some other data with another mode.
     </para>
     <para>Because the <see cref="CalculateSize"/> and formatted <see cref="Write"/> functions accept a variable
      length parameter array, you can also pass a single array of <see cref="System.Object"/> that contains all
      the parameters.
     </para>
     <para>For the formatted <see cref="Read"/> functions, you cannot pass format codes that have an unknown
      length (eg, <c>s</c> without a prefix, or anything with a <c>?</c> prefix). This restriction may be relaxed
      in the future.
     </para>
     <example>
      <para>See the following examples:</para>
<code>
// A simple example that first writes an array's length, and then writes the
// contents of the array (of Int32), using default endianness:
IOH.Write(stream, "d?d", Array.Length, Array);

// Codes taking Array/Vals accept both arrays and value lists. For instance:
short[] arr = new short[] { 1, 2, 4, 8 };
IOH.Write(stream, "4w", arr);        // writes eight bytes
IOH.Write(stream, "wwww", arr);      // writes the same eight bytes
IOH.Write(stream, "4w", 1, 2, 4, 8); // writes the same eight bytes

// Reading, however, doesn't consider "4w" and "wwww" to be the same:
IOH.Read(stream, "4w");   // reads an array containing 4 words
IOH.Read(stream, "wwww"); // reads four individual words

// An example taken from some .PSD writing code to begin the header. It
// writes the signature (8BPS) as ASCII, the version byte (1), six padding
// bytes, the number of channels (a word), the dimensions of the image (two
// integers), and two words specifying the bit depth per channel (8) and
// color mode (3 = RGB), using big-endian output.
// It uses whitespace to make the string a bit more readable.
IOH.Write(stream, "&gt;s B 6x w 2d 2w", "8BPS", 1, image.Channels,
          image.Height, image.Width, 8, 3);

// This is illegal because whitespace between a prefix and its associated
// format code is currently not allowed. This restriction may be relaxed
// in the future.
IOH.Write(stream, "6 x"); // BUG: no space allowed between prefix and code

// This example uses IOH.CalculateSize() and IOH.Write() in part of a
// network serialization implementation. It writes the player's name as
// a pascal string, the player's position, the length of a byte array,
// and the byte array itself, using big-endian output.
public int SizeOf()
{ return IOH.CalculateSize("&gt;p3d?B", player.Name, byteArray);
}
public void SerializeTo(byte[] buf, int index)
{ IOH.Write(buf, index, "&gt;p3d?B", player.Name, player.X, player.Y,
            byteArray.Length, byteArray);
}

// You can also pack all the parameters into a single object array, possibly
// with the parameter array and/or format string built dynamically.
object[] parms = new object[] { 1, 2.4f, stringVar, intArray };
byte[] output = IOH.Write("dfp?d", parms);
</code>
     </example>
    </remarks>
   </BinaryFormat>
  </IOH>
 </IO>

 <Mathematics>
  <GLMath>
   <AngleBetween>
    <summary>This method returns the angle between two points.</summary>
    <param name="start">The first point.</param>
    <param name="end">The second point.</param>
    <returns>Returns the angle between <paramref name="start"/> and <paramref name="end"/>, in radians.
    A return value of 0.0 indicates that the second point is to the right of the first point.
    </returns>
   </AngleBetween>
  </GLMath>

  <Fixed>
   <ToDateTime>
    <summary>Throws <see cref="InvalidCastException"/> because there's no sensible conversion to
    <see cref="DateTime"/>
    </summary>
    <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
    <returns>Doesn't return.</returns>
    <exception cref="InvalidCastException">Always thrown.</exception>
   </ToDateTime>
   <ToBoolean>
    <summary>Converts this value to a <see cref="Boolean"/>.</summary>
    <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
    <returns>A <see cref="Boolean"/> that will be false if the value is zero and true otherwise.</returns>
   </ToBoolean>
   <ToString1>
    <summary>Converts this fixed-point number into a string.</summary>
    <param name="format">A format code which controls the conversion to string.</param>
    <returns>A string representing this fixed-point number.</returns>
    <remarks>See <see cref="Double.ToString(string)"/> for information on the available formatting codes.</remarks>
   </ToString1>
   <ToString2>
    <summary>Converts this fixed-point number into a string.</summary>
    <param name="format">A format code which controls the conversion to string.</param>
    <param name="provider">An <see cref="IFormatProvider"/> used to control formatting, or null to use the default.</param>
    <returns>A string representing this fixed-point number.</returns>
    <remarks>See <see cref="Double.ToString(string)"/> for information on the available formatting codes.</remarks>
   </ToString2>
  </Fixed>

  <Line>
   <Line>
    <summary>Initializes this line from a point and a vector.</summary>
    <param name="start">A point on the line (or the start of the line segment).</param>
    <param name="vector">The line's direction. If you're defining a line segment, this should be the distance
    travelled from <paramref name="start"/>.
    </param>
   </Line>
   <Line2>
    <summary>Initializes this line from two points.</summary>
    <param name="start">A point on the line (or the start of the line segment).</param>
    <param name="end">Another point on the line (or the end of the line segment).</param>
    <remarks>Since the end point will need to be converted into a vector, some miniscule accuracy may be lost.
    Most notably, the <see cref="End"/> property may not be exactly equal to <paramref name="end"/>.
    </remarks>
   </Line2>
   <GetPoint>
    <summary>Gets one of the endpoints of the line segment.</summary>
    <param name="point">The index of the point to retrieve. A value of zero indicates that the start point should
    be returned, and a value of 1 indicates that the endpoint should be returned.
    </param>
    <returns>The requested point.</returns>
    <remarks>This method simply returns <see cref="Start"/> or <see cref="End"/> depending on the value of
    <paramref name="point"/>.
    </remarks>
    <exception cref="ArgumentOutOfRangeException">Thrown if <paramref name="point"/> is not 0 or 1.</exception>
   </GetPoint>
   <Equals>
    <summary>Determines whether the given object is a <see cref="Line"/> equal to this one.</summary>
    <param name="obj">An object to test for equality.</param>
    <returns>Returns true if <paramref name="obj"/> is a <see cref="Line"/> and equals this one.</returns>
   </Equals>
   <Equals3>
    <summary>Determines whether the given line is equal to this one, within a given margin of error.</summary>
    <param name="line">A line to test for equality.</param>
    <param name="epsilon">The given margin of error. The difference between both lines' <see cref="Start"/> and
    <see cref="Vector"/> properties must be less than or equal to this for them to qualify as equal.
    </param>
    <returns>Returns true if <paramref name="line"/> equals this line, within the given margin of error.</returns>
   </Equals3>
  </Line>

  <Point>
   <DistanceTo>
    <summary>Calculates the distance to another point.</summary>
    <param name="point">The point to calculate the distance to.</param>
    <returns>The distance to <paramref name="point"/>.</returns>
   </DistanceTo>
   <DistanceSquaredTo>
    <summary>Calculates the square of the distance to another point.</summary>
    <param name="point">The point to calculate the distance to.</param>
    <returns>The distance to <paramref name="point"/>, squared.</returns>
   </DistanceSquaredTo>
   <Equals>
    <summary>Determines whether the given object is a point equal to this one.</summary>
    <param name="obj">An object to test for equality.</param>
    <returns>Returns true if <paramref name="obj"/> is a <see cref="Point"/> and equals this one.</returns>
   </Equals>
   <Equals3>
    <summary>Determines whether the given point is equal to this one, within a given margin of error.</summary>
    <param name="point">A point to test for equality.</param>
    <param name="epsilon">The given margin of error. The difference between both points' X and Y coordinates must be
    less than or equal to this for them to qualify as equal.
    </param>
    <returns>Returns true if <paramref name="point"/> equals this point, within the given margin of error.</returns>
   </Equals3>
  </Point>

  <Vector>
   <DotProduct>
    <summary>Returns the dot product of this vector with another vector.</summary>
    <param name="v">The other operand for the dot product operation.</param>
    <returns>The dot product, which is the cosine of the angle between the two vectors, scaled by the magnitudes
    of both vectors.
    </returns>
   </DotProduct>
   <Equals>
    <summary>Determines whether the given object is a <see cref="Vector"/> equal to this one.</summary>
    <param name="obj">An object to test for equality.</param>
    <returns>Returns true if <paramref name="obj"/> is a <see cref="Vector"/> and equals this one.</returns>
   </Equals>
   <Equals3>
    <summary>Determines whether the given <see cref="Vector"/> is equal to this one, within a given margin of error.</summary>
    <param name="vect">A vector to test for equality.</param>
    <param name="epsilon">The given margin of error. The difference between both vectors' X and Y axes must be
    less than or equal to this for them to qualify as equal.
    </param>
    <returns>Returns true if <paramref name="vect"/> equals this one, within the given margin of error.</returns>
   </Equals3>
   <Normalize>
    <summary>Normalizes this vector to a length of 1.</summary>
    <remarks>Calling this method is invalid when the length of the vector is zero, since the vector would not be
    pointing in any direction and could not possibly be scaled to the correct length.
    </remarks>
   </Normalize>
   <Normalize2>
    <summary>Normalizes this vector to a given length.</summary>
    <param name="length">The desired length of the vector.</param>
    <remarks>Calling this method is invalid when the length of the vector is zero, since the vector would not be
    pointing in any direction and could not possibly be scaled to the given length.
    </remarks>
   </Normalize2>
   <Length>
    <summary>Calculates and returns the length of this vector, or sets the length.</summary>
    <remarks>Setting this property is not valid when the length of the vector is already zero, since the vector
    would not be pointing in any direction and could not possibly be scaled up to the given length.
    </remarks>
   </Length>
   <Normal>
    <summary>Returns a normalized copy of this vector.</summary>
    <value>A <see cref="Vector"/> pointing in the same direction as this one, but with a length of 1.0 (or as
    close as floating-point precision will let us get to 1.0).
    </value>
    <remarks>This property is not valid when the length of the vector is zero, since the vector would not be
    pointing in any direction and could not possibly be scaled to the correct length.
    </remarks>
   </Normal>
  </Vector>
 </Mathematics>

 <Network>
  <Common>
    <IsConnected>
      <summary>Returns true if the connection is open.</summary>
      <remarks>Note that this property may return true even if the connection has been broken. This method simply
      returns the connection state that existed when the most recent I/O operation was performed.
      </remarks>
    </IsConnected>
    <DefaultFlags>
      <summary>Gets or sets the default flags that will be used for sending messages.</summary>
      <remarks>If an overload of <see cref="Send"/> is called that does not have a flags parameter, the value of
      this property will be used. This property defaults to <see cref="SendFlag.ReliableSequential"/>.
      </remarks>
    </DefaultFlags>
    <GetQueueStatus>
      <summary>Gets information about the status of the receive and/or send queues.</summary>
      <param name="flags">A set of <see cref="QueueStat"/> flags that determine what data will be returned.</param>
      <returns>A <see cref="QueueStatus"/> structure containing the number and total size of messages waiting in
      the queues specified by <paramref name="flags"/>.
      </returns>
    </GetQueueStatus>
    <LagAverage>
      <summary>Gets or sets the average amount of lag in milliseconds.</summary>
      <remarks>This property can be used to help simulate unfavorable network conditions.</remarks>
    </LagAverage>
    <LagVariance>
      <summary>Gets or sets the amount that the lag varies from <see cref="LagAverage"/>, in milliseconds.</summary>
      <remarks>This property can be used to help simulate unfavorable network conditions.</remarks>
    </LagVariance>
    <RegisterTypes>
      <summary>Registers a list of types for automatic serialization/deserialization.</summary>
      <param name="types">An array of <see cref="System.Type"/> objects that will be registered.</param>
      <remarks>Registering a type allows it to be automatically serialized and deserialized. The types must be
      registered in the same order on both the server and client, or else bad things will happen. Types cannot be
      registered while a connection is open.
      <seealso cref="MessageConverter.RegisterTypes"/>
      </remarks>
    </RegisterTypes>
    <RegisterType>
      <summary>Registers a type for automatic serialization/deserialization.</summary>
      <param name="type">A <see cref="System.Type"/> that will be registered.</param>
      <remarks>Registering a type allows it to be automatically serialized and deserialized. The types must be
      registered in the same order on both the server and client, or else bad things will happen. Types cannot be
      registered while a connection is open.
      <seealso cref="MessageConverter.RegisterType"/>
      </remarks>
    </RegisterType>
    <UnregisterTypes>
      <summary>Unregisters a list of types.</summary>
      <param name="types">An array of <see cref="System.Type"/> to unregister.</param>
      <remarks>Registering a type allows it to be automatically serialized and deserialized. The types must be
      registered in the same order on both the server and client, or else bad things will happen. Types cannot be
      unregistered while a connection is open. <seealso cref="MessageConverter.UnregisterTypes"/>
      </remarks>
    </UnregisterTypes>
    <UnregisterType>
      <summary>Unregisters a type.</summary>
      <param name="type">A <see cref="System.Type"/> to unregister.</param>
      <remarks>Registering a type allows it to be automatically serialized and deserialized. The types must be
      registered in the same order on both the server and client, or else bad things will happen. Types cannot be
      unregistered while a connection is open. <seealso cref="MessageConverter.UnregisterType"/>
      </remarks>
    </UnregisterType>
    <ClearTypes>
      <summary>Unregisters all types.</summary>
      <remarks>Registering a type allows it to be automatically serialized and deserialized. The types must be
      registered in the same order on both the server and client, or else bad things will happen. Types cannot be
      unregistered while a connection is open. <seealso cref="MessageConverter.ClearTypes"/>
      </remarks>
    </ClearTypes>
  </Common>
  
  <Client>
    <Send>
      <Common>
        <summary>Queues a message for sending.</summary>
      </Common>
      <byteData><param name="data">An array of <see cref="System.Byte"/> containing the message data.</param></byteData>
      <Length><param name="length">The length of the message data.</param></Length>
      <Index>
        <param name="index">The index into <paramref name="data"/> at which the message data begins.</param>
      </Index>
      <Flags>
        <param name="flags">A set of <see cref="SendFlag"/> values that will be used to control how the message is sent.</param>
      </Flags>
      <objData>
        <param name="data">An object representing the message data. It will be automatically serialized, so its type
        must have been registered using <see cref="RegisterTypes"/>.
        </param>
      </objData>
      <Timeout>
        <param name="timeoutMs">A timeout value, in milliseconds, indicating when the message will expire. If the
        message hasn't been sent over the network before the timeout expires, the message will be dropped. A timeout
        value of zero indicates that the message will not expire.
        </param>
      </Timeout>
    </Send>
  </Client>

  <MessageConverter>
    <RegisterType>
      <remarks>
      <para>Registering a type allows it to be serialized and deserialized very efficiently. To achieve this
      efficiency, certain restrictions are placed upon the types that can be registered. However, for each
      restriction, there is a way to alleviate the restriction, so in effect, almost any type you create can be
      serialized.
      </para>
      <para>The primary restriction is that the type must be blittable. A blittable type is essentially a type
      that contains no references and has a predetermined memory layout. A value type (structure) that contains
      only blittable fields has a predetermined memory layout, as do all primitive types. A class can also have
      a predetermined memory layout if the <see cref="System.Runtime.InteropServices.StructLayoutAttribute"/>
      attribute is applied to it.
      </para>
      <para>Arrays of blittable types are also considered to be blittable. However, you should not register the
      array type directly. For any type that can be serialized, arrays of that type can also be serialized
      automatically. Simply register the element type of the array. So if you want to serialize an array of
      <see cref="System.Drawing.Point"/>, simply register the <see cref="System.Drawing.Point"/> class.
      However, note that serialization of arrays with more than one dimension is not supported.
      </para>
      <para>You can serialize non-blittable types and multi-dimensional arrays using the
      <see cref="INetSerializable"/> interface. Any type that implements the <see cref="INetSerializable"/>
      interface can be serialized by this code. However, for deserialization, an object implementing that interface
      must provide a default constructor (that is, a constructor that takes no arguments).
      </para>
      <para>If you are using multiple instances of the <see cref="MessageConverter"/> class, (for instance, one for
      serialization and one for deserialization), all instances must have the same types registered in the same
      order or else the behavior is undefined. (At best, an exception will be thrown during deserialization, but
      that cannot be relied upon. Data corruption or crashes may result.)
      </para>
      <para>One final note. For types that do not implement <see cref="INetSerializable"/>, an attempt will be made
      to determine whether the type is blittable or not. This process uses reflection and requires the
      <see cref="ReflectionPermission"/> permission with the <see cref="ReflectionPermissionFlag.TypeInformation"/>
      flag. If the flag is not present, the code will fall back onto using the <see cref="Marshal"/> class to
      handle blitting, and while this has been tested on Microsoft.NET Framework 1.1, it may not work properly on
      other implementations of the .NET runtime. For best results, the code should have that permission. Most code
      does by default, so you probably don't need to do anything to enable it.
      </para>
      </remarks>
    </RegisterType>
  </MessageConverter>

  <NetLink>
    <Send>
      <Common>
        <summary>Queues a message for sending.</summary>
        <param name="data">An array of <see cref="System.Byte"/> containing the message data.</param>
      </Common>
      <Length><param name="length">The length of the message data.</param></Length>
      <Index><param name="index">The index into <paramref name="data"/> at which the message data begins.</param></Index>
      <Flags>
        <param name="flags">A set of <see cref="SendFlag"/> values that will be used to control how the message is sent.</param>
      </Flags>
      <Timeout>
        <param name="timeoutMs">A timeout value, in milliseconds, indicating when the message will expire. If the
        message hasn't been sent over the network before the timeout expires, the message will be dropped. A timeout
        value of zero indicates that the message will not expire. <see cref="NoTimeout"/> cannot be used with this
        parameter.
        </param>
      </Timeout>
      <Tag>
        <param name="tag">A value that will be associated with the message. The tag value can be retrieved using the
        <see cref="LinkMessage.Tag"/> property.
        </param>
      </Tag>
    </Send>
  </NetLink>
  
  <Server>
    <Send>
      <Common>
        <summary>Queues a message for sending.</summary>
        <param name="toWho">The addressee of the message. This value may be one of the following:
        <list type="table">
          <listheader><term>Type</term></listheader>
          <item><term>null or <see cref="Players"/></term>
            <description>The message will be sent to all players that are not currently being dropped. If any
              exceptions occur due to a connection being broken, they will be ignored.
            </description>
          </item>
          <item><term><see cref="IEnumerable"/></term>
            <description>The message will be sent to all players in the list. If a player is currently being dropped,
              an exception will be raised. If any exceptions occur due to a connection being broken, they will be
              ignored.
            </description>
          </item>
          <item><term><see cref="ServerPlayer"/></term>
            <description>The message will be sent to the given player. No exceptions will be ignored.
            </description>
          </item>
        </list>
        </param>
      </Common>
      <RawSend>
        <param name="data">An array of <see cref="System.Byte"/> containing the serialized message data.
          The data should have been obtained from <see cref="Converter"/>.
        </param>
        <param name="orig">A reference to the original, unserialized message data.</param>
        <remarks>This method is used to send a raw block of data over the network. It is assumed that the data
          was obtained by serializing it with the <see cref="Converter"/>. The primary use for this is if you want
          to send a complex message to several players without first creating a collection containing them,
          or to send the same message at several different times.
        </remarks>
      </RawSend>
      <byteData><param name="data">An array of <see cref="System.Byte"/> containing the message data.</param></byteData>
      <Length><param name="length">The length of the message data.</param></Length>
      <Index>
        <param name="index">The index into <paramref name="data"/> at which the message data begins.</param>
      </Index>
      <Flags>
        <param name="flags">A set of <see cref="SendFlag"/> values that will be used to control how the message is sent.</param>
      </Flags>
      <objData>
        <param name="data">An object representing the message data. It will be automatically serialized, so its type
        must have been registered using <see cref="RegisterTypes"/>.
        </param>
      </objData>
      <Timeout>
        <param name="timeoutMs">A timeout value, in milliseconds, indicating when the message will expire. If the
        message hasn't been sent over the network before the timeout expires, the message will be dropped. A timeout
        value of zero indicates that the message will not expire.
        </param>
      </Timeout>
    </Send>
  </Server>
 </Network>

 <Video>
  <OpenGL>
   <TexImage2D>
    <summary>Uploads a surface to video memory as a 2d texture.</summary>
    <param name="surface">The surface to upload.</param>
    <returns>Returns true if the texture was successfully uploaded and false otherwise.</returns>
    <remarks>This method wraps the <see cref="GL.glTexImage2D"/> method. See the official OpenGL documentation for
    more information.
    </remarks>
   </TexImage2D>
   <WillTextureFit>
    <summary>Determines whether a texture of the given size and format can be created.</summary>
    <param name="internalFormat">The internal format OpenGL should use.</param>
    <param name="width">The width of the texture.</param>
    <param name="height">The height of the texture.</param>
    <returns>True if the texture can be created and false otherwise.</returns>
    <remarks>This method wraps <see cref="GL.glTexImage2D"/> using <c>GL_PROXY_TEXTURE_2D</c> to
    attempt to create the texture. It's especially useful for checking whether there's enough memory to
    create a given texture. However, it cannot be guaranteed that the texture would actually fit in high
    performance video memory (that it would actually be resident on the video card). To determine that, you need
    to upload the texture and then check the <c>GL_TEXTURE_RESIDENT</c> texture parameter.
    See the official OpenGL documentation for more information.
    </remarks>
   </WillTextureFit>
  </OpenGL>

  <Primitives>
    <Pixel>
      <Common>
        <summary>Writes a pixel on the destination surface, with optional alpha blending.</summary>
        <param name="dest">The surface to draw into.</param>
      </Common>
      <XY>
        <param name="x">The X coordinate of the pixel to change.</param>
        <param name="y">The Y coordinate of the pixel to change.</param>
      </XY>
      <Pt>
        <param name="pt">The coordinate of the pixel to change.</param>
      </Pt>
      <C>
        <param name="color">The color to use. If the color contains a non-opaque alpha level, the color will be
        alpha blended over the existing pixel.
        </param>
      </C>
      <CA>
        <param name="color">The color to use. The alpha component of this color is ignored.</param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the color
        will be alpha blended over the existing pixel.
        </param>
      </CA>
    </Pixel>

    <Line>
      <HLine>
        <summary>Draws a horizontal line, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the line will be drawn.</param>
        <param name="x1">The starting X coordinate of the line.</param>
        <param name="x2">The ending X coordinate of the line.</param>
        <param name="y">The row at which the line will be drawn.</param>
      </HLine>
      <VLine>
        <summary>Draws a vertical line, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the line will be drawn.</param>
        <param name="x">The column at which the line will be drawn.</param>
        <param name="y1">The starting Y coordinate of the line.</param>
        <param name="y2">The ending Y coordinate of the line.</param>
      </VLine>
      <Line>
        <summary>Draws a line, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the line will be drawn.</param>
      </Line>
      <AA>
        <summary>Draws an antialiased line, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the line will be drawn.</param>
      </AA>
      <Pt>
        <param name="p1">The starting point of the line.</param>
        <param name="p2">The ending point of the line.</param>
      </Pt>
      <XY>
        <param name="x1">The X coordinate of the starting point of the line.</param>
        <param name="y1">The Y coordinate of the starting point of the line.</param>
        <param name="x2">The X coordinate of the ending point of the line.</param>
        <param name="y2">The Y coordinate of the ending point of the line.</param>
      </XY>
      <C>
        <param name="color">The color to use. If the color contains a non-opaque alpha level, the line will be
        alpha blended onto the surface.
        </param>
      </C>
      <CA>
        <param name="color">The color to use. The alpha component of this color is ignored.</param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the line
        will be alpha blended onto the surface.
        </param>
      </CA>
    </Line>

    <Rectangle>
      <Hollow>
        <summary>Draws a hollow rectangle, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the rectangle will be drawn.</param>
      </Hollow>
      <Filled>
        <summary>Draws a filled rectangle, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the rectangle will be drawn.</param>
      </Filled>
      <Rect>
        <param name="rect">A <see cref="Rectangle"/> describing the rectangle to draw.</param>
      </Rect>
      <Pt>
        <param name="p1">A corner of the rectangle to draw.</param>
        <param name="p2">The opposite corner of the rectangle to draw.</param>
      </Pt>
      <XY>
        <param name="x1">The X coordinate of a corner of the rectangle to draw.</param>
        <param name="y1">The Y coordinate of a corner of the rectangle to draw.</param>
        <param name="x2">The X coordinate of the opposite corner of the rectangle to draw.</param>
        <param name="y2">The Y coordinate of the opposite corner of the rectangle to draw.</param>
      </XY>
      <C>
        <param name="color">The color to use. If the color contains a non-opaque alpha level, the rectangle will be
        alpha blended onto the surface.
        </param>
      </C>
      <CA>
        <param name="color">The color to use. The alpha component of this color is ignored.</param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the rectangle
        will be alpha blended onto the surface.
        </param>
      </CA>
    </Rectangle>

    <Circle>
      <Hollow>
        <summary>Draws a hollow circle, with optional alpha blending.</summary>
        <param name="radius">The radius of the circle, in pixels.</param>
        <param name="dest">The surface onto which the circle will be drawn.</param>
      </Hollow>
      <Filled>
        <summary>Draws a filled circle, with optional alpha blending.</summary>
        <param name="radius">The radius of the circle, in pixels.</param>
        <param name="dest">The surface onto which the circle will be drawn.</param>
      </Filled>
      <AA>
        <summary>Draws an antialiased hollow circle, with optional alpha blending.</summary>
        <param name="radius">The radius of the circle, in pixels.</param>
        <param name="dest">The surface onto which the circle will be drawn.</param>
      </AA>
      <Pt>
        <param name="pt">The circle's center point.</param>
      </Pt>
      <XY>
        <param name="x">The X coordinate of the circle's center point.</param>
        <param name="y">The Y coordinate of the circle's center point.</param>
      </XY>
      <C>
        <param name="color">The color to use. If the color contains a non-opaque alpha level, the circle will be
        alpha blended onto the surface.
        </param>
      </C>
      <CA>
        <param name="color">The color to use. The alpha component of this color is ignored.</param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the circle
        will be alpha blended onto the surface.
        </param>
      </CA>
      <AAC>
        <param name="color">The base color of the circle. Surrounding pixels will be blended with this color to provide
        antialiasing. If the color contains a non-opaque alpha level, the circle will be alpha blended onto the surface.
        </param>
      </AAC>
      <AACA>
        <param name="color">The base color of the circle. Surrounding pixels will be blended with this color to provide
        antialiasing. The alpha component of this color is ignored.
        </param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the circle
        will be alpha blended onto the surface.
        </param>
      </AACA>
    </Circle>

    <Ellipse>
      <Common>
        <param name="dest">The surface onto which the ellipse will be drawn.</param>
        <param name="xRadius">The radius of the ellipse along the X axis, in pixels.</param>
        <param name="yRadius">The radius of the ellipse along the Y axis, in pixels.</param>
      </Common>
      <Hollow>
        <summary>Draws a hollow ellipse, with optional alpha blending.</summary>
        <include file="documentation.xml" path="//Video/Primitives/Ellipse/Common/*"/>
      </Hollow>
      <Filled>
        <include file="documentation.xml" path="//Video/Primitives/Ellipse/Common/*"/>
      </Filled>
      <AA>
        <include file="documentation.xml" path="//Video/Primitives/Ellipse/Common/*"/>
      </AA>
      <Pt>
        <param name="pt">The ellipse's center point.</param>
      </Pt>
      <XY>
        <param name="x">The X coordinate of the ellipse's center point.</param>
        <param name="y">The Y coordinate of the ellipse's center point.</param>
      </XY>
      <C>
        <param name="color">The color to use. If the color contains a non-opaque alpha level, the ellipse will be
        alpha blended onto the surface.
        </param>
      </C>
      <CA>
        <param name="color">The color to use. The alpha component of this color is ignored.</param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the ellipse
        will be alpha blended onto the surface.
        </param>
      </CA>
      <AAC>
        <param name="color">The base color of the ellipse. Surrounding pixels will be blended with this color to provide
        antialiasing. If the color contains a non-opaque alpha level, the ellipse will be alpha blended onto the surface.
        </param>
      </AAC>
      <AACA>
        <param name="color">The base color of the ellipse. Surrounding pixels will be blended with this color to provide
        antialiasing. The alpha component of this color is ignored.
        </param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the ellipse
        will be alpha blended onto the surface.
        </param>
      </AACA>
    </Ellipse>

    <Pie>
      <Filled>
        <summary>Draws a filled pie, with optional alpha blending.</summary>
        <include file="documentation.xml" path="//Video/Primitives/Pie/Common/*"/>
      </Filled>
      <Hollow>
        <summary>Draws a hollow pie, with optional alpha blending.</summary>
      <include file="documentation.xml" path="//Video/Primitives/Pie/Common/*"/>
        </Hollow>
      <Pt>
        <param name="pt">The pie's center point.</param>
      </Pt>
      <XY>
        <param name="x">The X coordinate of the pie's center point.</param>
        <param name="y">The Y coordinate of the pie's center point.</param>
      </XY>
      <C>
        <param name="color">The color to use. If the color contains a non-opaque alpha level, the pie will be
        alpha blended onto the surface.
        </param>
      </C>
      <CA>
        <param name="color">The color to use. The alpha component of this color is ignored.</param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the pie
        will be alpha blended onto the surface.
        </param>
      </CA>
      <Common>
        <param name="dest">The surface into which the pie will be drawn.</param>
        <param name="radius">The radius of the pie, in pixels.</param>
        <param name="startDegs">The starting angle of the pie's arc, in degrees. 0 is to the right.</param>
        <param name="endDegs">The ending angle of the pie's arc, in degrees. 0 is to the right.</param>
      </Common>
    </Pie>
    
    <Triangle>
      <Hollow>
        <summary>Draws a hollow triangle, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the triangle will be drawn.</param>
      </Hollow>
      <Filled>
        <summary>Draws a filled triangle, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the triangle will be drawn.</param>
      </Filled>
      <AA>
        <summary>Draws an antialiased hollow triangle, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the triangle will be drawn.</param>
      </AA>
      <Pt>
        <param name="p1">The first point of the triangle.</param>
        <param name="p2">The second point of the triangle.</param>
        <param name="p3">The third point of the triangle.</param>
      </Pt>
      <XY>
        <param name="x1">The X coordinate of the first point of the triangle.</param>
        <param name="y1">The Y coordinate of the first point of the triangle.</param>
        <param name="x2">The X coordinate of the second point of the triangle.</param>
        <param name="y2">The Y coordinate of the second point of the triangle.</param>
        <param name="x3">The X coordinate of the third point of the triangle.</param>
        <param name="y3">The Y coordinate of the third point of the triangle.</param>
      </XY>
      <C>
        <param name="color">The color to use. If the color contains a non-opaque alpha level, the triangle will be
        alpha blended onto the surface.
        </param>
      </C>
      <CA>
        <param name="color">The color to use. The alpha component of this color is ignored.</param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the triangle
        will be alpha blended onto the surface.
        </param>
      </CA>
      <AAC>
        <param name="color">The base color of the triangle. Surrounding pixels will be blended with this color to
        provide antialiasing. If the color contains a non-opaque alpha level, the triangle will be alpha blended onto
        the surface.
        </param>
      </AAC>
      <AACA>
        <param name="color">The base color of the triangle. Surrounding pixels will be blended with this color to
        provide antialiasing. The alpha component of this color is ignored.
        </param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the triangle
        will be alpha blended onto the surface.
        </param>
      </AACA>
    </Triangle>
    
    <Polygon>
      <Hollow>
        <summary>Draws a hollow polygon, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the polygon will be drawn.</param>
      </Hollow>
      <Filled>
        <summary>Draws a filled polygon, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the polygon will be drawn.</param>
      </Filled>
      <AA>
        <summary>Draws an antialiased hollow polygon, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the polygon will be drawn.</param>
      </AA>
      <A>
        <param name="points">An array of points defining the polygon.</param>
      </A>
      <AL>
        <param name="points">An array of points defining the polygon.</param>
        <param name="index">The starting index into <paramref name="points"/>.</param>
        <param name="length">The number of points to read from <paramref nam="points"/>, starting from
        <paramref name="index"/>.
        </param>
      </AL>
      <C>
        <param name="color">The color to use. If the color contains a non-opaque alpha level, the polygon will be
        alpha blended onto the surface.
        </param>
      </C>
      <CA>
        <param name="color">The color to use. The alpha component of this color is ignored.</param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the polygon
        will be alpha blended onto the surface.
        </param>
      </CA>
      <AAC>
        <param name="color">The base color of the polygon. Surrounding pixels will be blended with this color to
        provide antialiasing. If the color contains a non-opaque alpha level, the polygon will be alpha blended onto
        the surface.
        </param>
      </AAC>
      <AACA>
        <param name="color">The base color of the polygon. Surrounding pixels will be blended with this color to
        provide antialiasing. The alpha component of this color is ignored.
        </param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the polygon
        will be alpha blended onto the surface.
        </param>
      </AACA>
    </Polygon>
    
    <Curve>
      <Common>
        <summary>Draws a bezier curve, with optional alpha blending.</summary>
        <param name="dest">The surface onto which the curve will be drawn.</param>
        <param name="steps">The number of interpolation steps. Higher numbers of steps will yield smoother curves,
        but with correspondingly reduced performance.
        </param>
      </Common>
      <C>
        <param name="color">The color to use. If the color contains a non-opaque alpha level, the curve will be
        alpha blended onto the surface.
        </param>
      </C>
      <CA>
        <param name="color">The color to use. The alpha component of this color is ignored.</param>
        <param name="alpha">The alpha value to use, from 0 (transparent) to 255 (opaque). If not opaque, the curve
        will be alpha blended onto the surface.
        </param>
      </CA>
      <A>
        <param name="points">An array of points defining the curve.</param>
      </A>
      <AL>
        <param name="points">An array of points defining the curve.</param>
        <param name="index">The starting index into <paramref name="points"/>.</param>
        <param name="length">The number of points to read from <paramref nam="points"/>, starting from
          <paramref name="index"/>.
        </param>
      </AL>
    </Curve>
  </Primitives>

  <PSDCodec>
   <IsPSD>
    <summary>Determines whether a file is a PSD image file that can be read by this codec.</summary>
    <returns>Returns true if the file looks like it contains PSD image data and false otherwise.</returns>
    <remarks>This function does not read all the data from the PSD image file to determine whether it could be
    loaded successfully and doesn't use any unsupported features. It only checks to see whether the image file has
    the right header signature and version number for the PSD format the codec can understand.
    </remarks>
   </IsPSD>
   <LayerReading>
    <exception cref="InvalidOperationException">
    Thrown if
    <para>The codec is not in a reading mode.</para>
    -or-
    <para>All layers have been read already.</para>
    </exception>
   </LayerReading>
   <Read>
    <summary>Reads a PSD image from the given file.</summary>
    <returns>A <see cref="PSDImage"/> containing the flattened image and all the layers.</returns>
    <include file="documentation.xml" path="//Video/PSDCodec/Reading_X/*"/>
   </Read>
   <ReadComposite>
    <summary>Reads the flattened image from a PSD file.</summary>
    <returns>A <see cref="Surface"/> containing the flattened image from the PSD file.</returns>
    <include file="documentation.xml" path="//Video/PSDCodec/Reading_X/*"/>
   </ReadComposite>
   <Reading_X>
    <exception cref="ArgumentException">Thrown if the file does not contain a valid PSD image.</exception>
    <exception cref="NotSupportedException">Thrown if the PSD image uses unsupported features.</exception>
    <exception cref="InvalidOperationException">Thrown if the codec is currently in a reading or writing mode.</exception>
   </Reading_X>
   <StartReading>
    <summary>Starts reading a PSD image.</summary>
    <returns>The <see cref="PSDImage"/> object in which data for this file will be stored. All fields except
    <see cref="Surface"/> fields will be populated.
    </returns>
    <include file="documentation.xml" path="//Video/PSDCodec/Reading_X/*"/>
   </StartReading>
   <StartWriting>
    <summary>Starts writing a PSD image.</summary>
    <param name="image">A <see cref="PSDImage"/> object with all fields populated, including layer information,
    except <see cref="Surface"/> fields, which are not required.
    </param>
    <remarks>All data in <paramref name="image"/> is written into the PSD header and is expected to remain the
    same throughout the writing process.
    </remarks>
    <include file="documentation.xml" path="//Video/PSDCodec/Writing_X/*"/>
   </StartWriting>
   <Write>
    <summary>Writes a PSD image.</summary>
    <param name="image">A <see cref="PSDImage"/> object with all fields populated, including layer information
    and image data (<see cref="Surface"/> fields).
    </param>
    <include file="documentation.xml" path="//Video/PSDCodec/Writing_X/*"/>
   </Write>
   <Write_Surface>
    <summary>Writes a PSD image.</summary>
    <param name="surface">A <see cref="Surface"/> which will be used as the flattened image in the PSD file.</param>
    <remarks>The resulting PSD image will have no layers.</remarks>
    <exception cref="ArgumentNullException">Thrown if <paramref name="surface"/> or <paramref name="stream"/> is
    null.
    </exception>
    <exception cref="InvalidOperationException">Thrown if the codec is currently in a reading or writing mode.</exception>
   </Write_Surface>
   <Writing_X>
    <exception cref="ArgumentNullException">Thrown if <paramref name="image"/> or <paramref name="stream"/> is
    null.
    </exception>
    <exception cref="ArgumentException">Thrown if <paramref name="image"/> contains invalid data.</exception>
    <exception cref="InvalidOperationException">Thrown if the codec is currently in a reading or writing mode.</exception>
   </Writing_X>
  </PSDCodec>
  
  <Surface>
    <Cons>
      <FromBmp>
        <summary>This constructor attempts to initialize the surface from a <see cref="System.Drawing.Bitmap"/>.</summary>
        <param name="bitmap">The <see cref="System.Drawing.Bitmap"/> containing the image to initialize this
        surface with.
        </param>
      </FromBmp>
      <FromDims>
        <summary>Creates an empty surface with the given dimensions and bit depth.</summary>
        <param name="width">The width of the surface to create.</param>
        <param name="height">The height of the surface to create.</param>
        <param name="depth">The bit depth of the surface to create, in bits per pixel.</param>
      </FromDims>
      <FromFormat>
        <summary>Creates an empty surface with the given dimensions and pixel format</summary>
        <param name="width">The width of the surface to create.</param>
        <param name="height">The height of the surface to create.</param>
        <param name="format">The <see cref="PixelFormat"/> of the surface to create.</param>
      </FromFormat>
    </Cons>
    
    <Fill>
      <Whole>
        <summary>Fills the surface with the specified color.</summary>
      </Whole>
      <Rect>
        <summary>Fills a portion of the surface with the specified color.</summary>
        <param name="rect">The portion of the surface to fill.</param>
      </Rect>
      <C>
        <param name="color">The color to fill with.</param>
        <remarks>The color will be converted to a raw pixel value with <see cref="MapColor(Color)"/> before the area
        is filled. This method should not be called while the surface is locked. This method respects the
        <see cref="ClipRect"/> set on the surface.
        </remarks>
      </C>
      <R>
        <param name="color">The raw pixel value to fill with.</param>
        <remarks>This method should not be called while the surface is locked. This method respects the
        <see cref="ClipRect"/> set on the surface.
        </remarks>
      </R>
    </Fill>
    
    <Blit>
      <Whole>
        <summary>Blits this surface onto a destination surface at the given point.</summary>
        <param name="dest">The destination surface to blit onto.</param>
      </Whole>
      <Part>
        <summary>Blits a portion of this surface onto a destination surface at the given point.</summary>
        <param name="dest">The destination surface to blit onto.</param>
        <param name="src">The portion of this surface to blit.</param>
      </Part>
      <Pt>
        <param name="dpt">The destination point where the blit will begin.</param>
      </Pt>
      <XY>
        <param name="dx">The X coordinate of the destination point where the blit will begin.</param>
        <param name="dy">The Y coordinate of the destination point where the blit will begin.</param>
      </XY>
    </Blit>
    
    <GetPixel>
      <C>
        <summary>Returns the color of the pixel at the specified point.</summary>
        <returns>The <see cref="Color"/> of the pixel.</returns>
        <remarks>This method reads the raw pixel value and calls <see cref="MapColor(uint)"/> to convert it to a
        <see cref="Color"/>.
        This method is quite inefficient. Also, it uses <see cref="Lock"/> to lock the
        surface first if necessary. If you are reading/writing many pixels at once, you should consider locking
        the surface before all the operations and unlocking it afterwards, or doing direct pixel access yourself
        using <see cref="Data"/>.
        </remarks>
      </C>
      <R>
        <summary>Gets the raw value of the pixel at the specified point.</summary>
        <returns>The raw pixel value for the specified point.</returns>
        <remarks>This method is quite inefficient.
        Also, it uses <see cref="Lock"/> to lock the surface first if necessary. If you are reading/writing many
        pixels at once, you should consider locking the surface before all the operations and unlocking it afterwards,
        or doing direct pixel access yourself using <see cref="Data"/>.
        </remarks>
      </R>
      <Pt>
        <param name="point">The point whose color value will be returned.</param>
      </Pt>
      <XY>
        <param name="x">The X coordinate of the point whose color value will be returned.</param>
        <param name="y">The Y coordinate of the point whose color value will be returned.</param>
      </XY>
    </GetPixel>
    
    <PutPixel>
      <C>
        <summary>Sets the color of the pixel at the specified point.</summary>
        <param name="color">The color value to set the pixel to.</param>
        <remarks>This method calls <see cref="MapColor(Color)"/> to convert the color into a raw pixel value.
        This method respects the <see cref="ClipRect"/> set up for the surface. This method is quite inefficient.
        Also, it uses <see cref="Lock"/> to lock the surface first if necessary. If you are reading/writing many
        pixels at once, you should consider locking the surface before all the operations and unlocking it afterwards,
        or doing direct pixel access yourself using <see cref="Data"/>.
        </remarks>
      </C>
      <R>
        <summary>Sets the raw pixel value of the pixel at the specified point.</summary>
        <param name="color">The raw color value to set the pixel to.</param>
        <remarks>This method respects the <see cref="ClipRect"/> set up for the surface.
        This method is quite inefficient.
        Also, it uses <see cref="Lock"/> to lock the surface first if necessary. If you are reading/writing many
        pixels at once, you should consider locking the surface before all the operations and unlocking it afterwards,
        or doing direct pixel access yourself using <see cref="Data"/>.
        </remarks>
      </R>
      <Pt>
        <param name="point">The point whose color value will be set.</param>
      </Pt>
      <XY>
        <param name="x">The X coordinate of the point whose color value will be set.</param>
        <param name="y">The Y coordinate of the point whose color value will be set.</param>
      </XY>
    </PutPixel>
    
    <SetPalette>
      <Common>
        <exception cref="ArgumentNullException">Thrown if <paramref name="colors"/> is null.</exception>
        <param name="colors">An array of <see cref="Color"/> to set the palette with.</param>
      </Common>
      <ANCommon>
        <param name="numColors">The number of colors to set.</param>
        <remarks>If <paramref name="numColors"/> is smaller than the number of colors in the palette, part of the
        palette will remain unchanged.
        </remarks>
      </ANCommon>

      <Logical>
        <summary>Sets the logical palette colors.</summary>
        <include file="documentation.xml" path="//Video/Surface/SetPalette/Common/*"/>
      </Logical>

      <A>
        <remarks>If <paramref name="colors"/> contains too few colors, part of the palette will remain unchanged.
        </remarks>
      </A>
      <AN>
        <include file="documentation.xml" path="//Video/Surface/SetPalette/ANCommon/*"/>
        <remarks>If <paramref name="numColors"/> is smaller than the number of colors in the palette, part of the
        palette will remain unchanged.
        </remarks>
        <exception cref="ArgumentOutOfRangeException">Thrown if the number of colors would overflow the palette.
        </exception>
      </AN>
      <AA>
        <include file="documentation.xml" path="//Video/Surface/SetPalette/AN/*"/>
        <param name="startIndex">The starting index within the palette where colors will be written.</param>
        <param name="startColor">The starting index within the color array from where colors will be read.</param>
        <exception cref="ArgumentOutOfRangeException">Thrown if the number of colors would overflow the palette or
        one of the indices are invalid.
        </exception>
      </AA>
      <EN>
        <exception cref="ArgumentOutOfRangeException">Thrown if the number of colors would overflow the palette.
        </exception>
      </EN>
    </SetPalette>
    
    <CreateCompatible>
      <summary>Creates a surface with the same pixel format as this one, and a specified size.</summary>
      <param name="width">The width of the new surface.</param>
      <param name="height">The height of the new surface.</param>
      <returns>A <see cref="Surface"/> with the same pixel format as this one.</returns>
    </CreateCompatible>
    
    <CloneDisplay>
      <summary>Returns a copy of this surface in the same general format as the display surface, suitable for fast
      blitting.
      </summary>
      <returns>A new <see cref="Surface"/> containing the same image data, converted to the same general pixel format
      of the display surface. The new surface will have an alpha channel if this surface has an alpha channel.
      </returns>
    </CloneDisplay>
  </Surface>
 </Video>
</GameLib>